source ~/.dotfiles/sh/profile

#. ~/.nix-profile/share/fzf/completion.bash
#. ~/.nix-profile/share/fzf/key-bindings.bash
. ~/.nix-profile/share/git/contrib/completion/git-completion.bash


shopt -s \
    dotglob \
    extglob


shopt -s histappend
HISTSIZE=1000
HISTFILESIZE=1000
HISTCONTROL=ignoredups:erasedups
HISTTIMEFORMAT='%F %T  '
PROMPT_COMMAND="history -a${PROMPT_COMMAND:+; $PROMPT_COMMAND}"


function precmd { :; }
PROMPT_COMMAND="${PROMPT_COMMAND:+$PROMPT_COMMAND; }precmd"

function preexec { :; }
trap 'preexec' DEBUG


function prompt {
    "set_$1_prompt"
}
complete -W 'spartan basic twoline statusline' prompt

function set_spartan_prompt {
    PS1="\[\e[1m\]❯ \[\e[0m\]"
    PS2="╎ "
    function precmd { :; }
    function preexec { :; }
}

function set_basic_prompt {
    PS2="╎ "
    function precmd {
        set_status_line -1
        printf "%b " "$STATUS_LINE"
        PS1="\[\e[1m\]❯ \[\e[0m\]"
    }
    function preexec { :; }
}

function set_twoline_prompt {
    PS2="╎ "
    function precmd {
        set_status_line
        printf "\n%b\n" "$STATUS_LINE"
        PS1="\[\e[1m\]❯ \[\e[0m\]"
    }
    function preexec { :; }
}

function set_statusline_prompt {
    # # Floating status line prompt
    #
    # Shows a line of status information that "floats" directly below the main,
    # currently active prompt:
    #
    #     $ _
    #     [status information is shown here]
    #
    # The status line is cleared after each command so that it's only visible
    # under the next prompt. For example, typing `echo no status line here` at
    # the prompt above would produce the following terminal history:
    #
    #     $ echo no status line here
    #     no status line here
    #     $ _
    #     [status information is shown here]

    # # How it works
    # 
    # Various control sequences are printed during PROMPT_COMMAND and the debug
    # trap to move the cursor around and clear characters as needed. Inspired
    # by https://unix.stackexchange.com/questions/1022/display-stuff-below-the-prompt-at-a-shell-prompt..
    # See also,
    # - https://en.wikipedia.org/wiki/ANSI_escape_code.
    # - https://invisible-island.net/xterm/ctlseqs/ctlseqs.pdf
    # - https://superuser.com/questions/840526/status-line-in-linux-shell
    # - Interesting example using readline: https://mina86.com/2015/bash-right-prompt/

    # # Caveats
    #
    # This prompt works most of the time. However, there are some issues:
    #
    # - The status line isn't cleared when a long command wraps to the next
    #   line, it gets overwritten instead. A workaround is to hit backspace when
    #   the command is wrapped, which will clear the status line out of the way.
    #
    # - Completion suggestions are displayed on top of the status line without
    #   clearing it first. If there aren't enough suggestions to completely
    #   cover the status line, then the a portion of the status line will be
    #   visible to the right of the suggestions.
    #
    # - Lines can sometimes be redrawn funny when the terminal is resized.

    # Clear the status line for line continuation
    PS2="\[\e[K\]╎ "

    function precmd {
        # Print the status line, moving the cursor to a new line below, then
        # move the cursor back up to where it started.
        set_status_line
        printf "\n%b\e[F" "${STATUS_LINE}"

        # Set PS1 and indicate that the status line should be cleared during
        # the next precmd.
        PS1="\[\e[1m\]❯ \[\e[0m\]"
        __STATUS_LINE_CLEARED=0
    }

    function preexec {
        # Only run once, even with multiple commands in PROMPT_COMMAND
        [[ "$__STATUS_LINE_CLEARED" == 1 ]] && return

        # Clear the current line
        printf '\e[K'
        __STATUS_LINE_CLEARED=1
    }

    # Some readline hackery to make sure the status line is properly cleared
    # while completing.
    # - Can't bind a key to multiple commands directly, but *can* bind to a macro.
    # - Using meta-ctrl keys because I'm pretty sure they're not bound to anything
    #   by default.
    #
    # Note: This solution isn't perfect. Completing when at the bottom of the
    # terminal will cause the current line+status line to shift up by 1,
    # overwriting the previous line. Disabling this for now until I come up
    # with a better solution.
    #
    #bind -x '"\M-\C-l":clear_status_line_before_completion'
    #bind '\M-\C-i:complete'
    #bind -x '"\M-\C-s":status && printf "\e[2F"'
    #bind '\C-i:"\M-\C-l\M-\C-i\M-\C-s"'
    ## To restore, I think \M-\C-l, \M-\C-i, and \M-\C-s can be cleared with 'bind
    ## -r', then bind \C-i to complete.
    #
    #function clear_status_line_before_completion {
    #    printf '\e[E\e[K\e[2F'
    #}
}

prompt statusline


alias st=status
